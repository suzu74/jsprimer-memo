# js-primer memo

### 第一部: 基本文法

#### JavaScriptとは

* JavaScriptは主にウェブブラウザの中で動くプログラミング言語
*  ウェブサイトで操作をしたら表示が書き換わったり、ウェブサイトのサーバーと通信してデータを取得したりと現在のウェブサイトには欠かせないプログラミング言語
     * JavaScriptを活用してアプリケーションのように操作できるウェブサイトをウェブアプリと呼ぶ

* ウェブブラウザだけでなくNode.jsというサーバー側のアプリケーションを作る仕組みでも利用されている。
    * デスクトップアプリやスマートフォンアプリ、IoT（Internet of Things）デバイスでもJavaScriptを使って動かせるものもある
        * つまりかなり広い範囲で使われている

##### JavaScriptとECMAScript

* JavaScriptという言語はECMAScriptという仕様によって動作が決められている
    *  ECMAScriptという仕様では、どの実行環境でも共通な動作のみが定義されている
        * つまり基本的にどの実行環境でも同じ動作をする
            * 一方で、実行環境によって異なる部分もある
                * 実行環境によって必要な機能は異なるため、それらの機能は実行環境ごとに定義（実装）されているため
                    * つまり、、、、ECMAScriptの仕様で定義されている機能を学ぶことで、どの実行環境でも対応できる基本的な部分を学べる

##### JavaScriptってどのような言語？

* 元々Netscape Navigatorというブラウザのために開発されたプログラミング言語
    * 大部分がオブジェクト（値や処理を1つにまとめたもの）で、そのオブジェクト同士のコミュニケーションによって成り立っている 
        * オブジェクトは主に３つ存在する
            * ECMAScriptの仕様として定められたオブジェクト
            * 実行環境が定義したオブジェクト
            * ユーザーの定義したオブジェクト

##### 大文字と小文字を区別する

* JavaScriptは大文字小文字を区別
    * nameという変数を大文字と小文字で書いた場合に、 それぞれは別々のnameとNAMEという名前の変数として認識
    * 大文字で開始しなければならないといった命名規則が意味を持つケースも無い

##### 予約語を持つ

* 特別な意味を持つキーワードがあり、これらは予約語と呼ばれる
     * 変数を宣言するconstも予約語
        * つまりconstという名前の変数名は宣言できない

##### 文はセミコロンで区切られる

* JavaScriptは、文（Statement）ごとに処理していく
    * 文はセミコロン（;）によって区切られる
        *  特殊なルールに基づき、セミコロンがない文も、行末に自動でセミコロンが挿入されるという仕組みも持っている
            * Rubyに慣れているので、セミコロンはつい忘れそう。。。。

#####　strict mode

* 名前のとおり厳格な実行モードで、古く安全でない構文や機能が一部禁止
* `use strict`という文字列をファイルまたは関数の先頭に書くことで、そのスコープにあるコードはstrict modeで実行される
* strict modeでは、evalやwithといったレガシーな機能や構文を禁止
    * さらに明らかな問題を含んだコードに対しては早期的に例外を投げることで、開発者が間違いに気づきやすくしてくれる

* 今まではあまり考えたことなかった、`use strict`だったので意味について再確認できた

#####　実行コンテキスト: ScriptとModule

* 実行コンテキストとして"Script"と"Module"がある
    * 特別意識する必要なし
        *  "Script"の実行コンテキストでは、デフォルトはstrict modeではない
        * "Module"の実行コンテキストでは、デフォルトがstrict modeである

##### JavaScriptの仕様は毎年更新される

* 読了

#### コメント

* コメントに関してはRubyでもあるので書き方は違えどOK
* コメントの書き方には、一行コメントと複数行コメントの2種類

##### 一行コメント

* // 以降から行末までがコメントとして扱われる

##### 複数行コメント

* /* と */で囲まれた範囲がコメントとして扱われる

##### [ES2015] HTML-likeコメント

* HTML-likeコメントは名前のとおり、HTMLのコメントと同じ表記
    * <!-- と -->がコメントとなる

##### まとめ

* コメントの書き方について学んだ
    * 特別難しい内容はなかった。
        * HTML-likeコメンは初耳だった

#### 変数と宣言

* 変数を宣言する方法はconst、let、varの3つ
    * varはもっとも古くからある変数宣言のキーワード(意図しない動作を作りやすい問題があった)
        * ECMAScript 2015で、varの問題を改善するためにconstとletという新しいキーワードが導入

##### [ES2015] const

* constキーワードで、再代入できない変数の宣言とその変数が参照する値（初期値）を定義
    * また、const、let、varどのキーワードも共通の仕組みで、変数同士を,（カンマ）で区切ることにより、同時に複数の変数を定義できる

```
const 変数名 = 初期値;
```

```
const bookTitle = "JavaScript Primer";
const bookCategory = "プログラミング";

上記は以下のように少し簡潔にかける
const bookTitle = "JavaScript Primer",
      bookCategory = "プログラミング";
```

* constは再代入できない変数を宣言するキーワード
    * そのため、constキーワードで宣言した変数に対して、後から値を代入することはできない
        * Rubyは警告はでるが再代入できる、、、。

* 一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られている
    * なので変数に対して値を再代入する必要がない場合は、constキーワードで変数宣言することを推奨
        * 再代入したい場合は次に紹介するletを使う

##### [ES2015] let

* letキーワードでは、値の再代入が可能な変数を宣言できる
    * letはconstとは異なり、初期値を指定しない変数も定義できる
        * 初期値が指定されなかった変数はデフォルト値としてundefinedという値で初期化
            * letで宣言した変数に対しては何度でも値の代入が可能

```
let bookTitle; #まずは初期化
bookTitle = "JavaScript Primer";
```

```
let count = 0;
count = 1; # 一度letで宣言しているのであとは宣言しないで大丈夫、、、、
count = 2;
count = 3;
```

#####　varの問題

* varはletとよく似ていますが、varキーワードには同じ名前の変数を再定義できてしまう問題がある
    * letやconstでは、同じ名前の変数を再定義すると構文エラーになる
    * 一方、varは同じ名前の変数を再定義できる
        * letはvarを改善したバージョン」
            * varの問題についてあまり意識したことがなかった、、、、。

```
// "x"という変数名で変数を定義する
let x;
// 同じ変数名の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x

// "x"という変数を定義する
var x = 1;
// 同じ変数名の変数"x"を定義できる
var x = 2;
// 変数xは2となる
```

##### [コラム] なぜletやconstは追加されたのか？

* 読了

##### 変数名に使える名前のルール

* 変数名の名前（識別子）のルール
    * 半角のアルファベット、_（アンダースコア）、$（ダラー）、数字を組み合わせた名前にする
    * 変数名は数字から開始できない
    * 予約語と被る名前は利用できない
        * 予約語とは、varのとかifように構文として意味を持つキーワード

##### [コラム] constは定数ではない

* constは「再代入できない変数」を定義する変数宣言
    * 必ずしも定数を定義するわけではない

* では定数とは？？
    * 定数とは、一度定義した名前（変数名）が常に同じ値を示すもの
         * const宣言によって定数に近い変数を定義できる
            * const宣言によって定義した変数を、変更できないプリミティブな値で初期化すれば、それは実質的に定数となる
                * プリミティブな値とは、数値や文字列などオブジェクト以外のデータ（他のパートで詳しく学ぶ）
            * しかしオブジェクトなどもconst宣言できる
                * オブジェクトという値そのものは、初期化したあとでも変更可
                    * てっきりconstは定数宣言だと思っていた、、、、。
            * const宣言の特性として「再代入できない変数」を定義すると覚えておく

```
// `const`でオブジェクトを定義している
const object = {
    key: "値"
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値";
```

#####　まとめ

* constは、再代入できない変数を宣言できる
* letは、再代入ができる変数を宣言できる
* varは、再代入ができる変数を宣言できる
    * しかし、varにはいくつかの問題が知られている

* constは再代入を禁止することで、ミスから発生するバグを減らすことが期待できる
    * 変数を宣言する場合には、まずconstで定義できないかを検討し、できない場合はletを使うことを推奨されている

#### 値の評価と表示

* 値の評価方法について学ぶ
    * 値の評価とは、入力した値を評価してその結果を返すこと

##### ブラウザでJavaScriptを実行する

* 読了

##### Console API

* デバッグとして便利

##### コードの評価とエラー

* エラーには多く分けて構文エラーと実行時エラーの2種類

##### 構文エラー

* JavaScriptエンジンは、コードをパース（解釈）してから、プログラムとして実行できる形に変換して実行
    * コードをパースする際に文法の問題が見つかると、その時点で構文エラーが発生する

##### 実行時エラー

* プログラムを実行している最中に発生するエラー
    * APIに渡す値の問題から起きるTypeErrorや存在しない変数を参照しようとして起きるReferenceErrorなどさまざまな種類がある
        * 構文は正しいが、別でエラーが起きている

* どこまではちゃんと実行できたか順番に追っていくような、エラーの原因を特定する作業が必要になる場合がある

#####　まとめ

* 読了

#### データ型とリテラル

##### データ型

* JavaScriptは動的型付け言語
    * 静的型付け言語のような変数の型はない
        * しかし、文字列、数値、真偽値といった値の型は存在 ⇨　値の型のことをデータ型
            * 今まで静的型付け言語を学んだことが無いから、ここら辺の違いの理解が曖昧

* データ型は大きく分けて２つ(プリミティブ型とオブジェクト)
    * プリミティブ型
        * 真偽値や数値などの基本的な値の型
            * 一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性をもつ
            * 文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種
    * オブジェクト（複合型）
        * オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合
            * 一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性
                * 値そのものではなく値への参照を経由して操作されるため、参照型のデータとも呼ばれる

* データ型を細かく見ていくと、6つのプリミティブ型とオブジェクト
    * 真偽値（Boolean）、数値（Number）、文字列（String）、undefined、 null、 シンボル（Symbol）
    * 上記以外がオブジェクト(オブジェクト、配列、関数、正規表現、Dateなど)
    * typeof演算子を使うことで調べることが可能
        * ただし、typeof nullが"object"となるのは、仕様のバグ
        * 配列とオブジェクトがどちらも"object"という判定結果
            * 基本的にtypeof演算子は、プリミティブ型またはオブジェクトかを判別するものです。 オブジェクトの詳細な種類を判定できない

##### リテラル

* リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの
    * 例）　"と"で囲んだ範囲が文字列リテラル

#####　真偽値（Boolean）

* 真偽値にはtrueとfalseのリテラルがある

#####　数値（Number）

* 数値は大きく分けて42のような整数リテラルと3.14159のような浮動小数点数リテラルの２種類
    * さらに整数リテラルには4種類
        * 10進数 2進数 8進数 16進数
            * 上記の理解が曖昧。再度復習の余地あり
    *  浮動小数点数は2種類の表記
        * 3.14159 のような .（ドット）を含んだ数値
            * 0からはじまる浮動小数点数は、0を省略可
                * .をオブジェクトにおいて利用する機会が多いため、 0からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせる
        * 2e8 のような e または E を含んだ数値

##### 文字列（String）

* ダブルクォートとシングルクォートで囲った場合は全く同じ
    * Rubyとは違う、、、、。
* ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できないので、\nを使う
    * テンプレートリテラルは違って、直感的にかける！
        * ただし、他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、\を使ってエスケープする必要あり

##### nullリテラル

* nullは「値がない」ということを表現する値

##### [コラム] undefinedはリテラルではない

* undefinedはただのグローバル変数で、undefinedという値を持っているだけ
    * つまり、undefinedには値を代入できる（非推奨）
    * あまり、nullとかundefinedを意識したことがなかった

##### オブジェクトリテラル

* JavaScriptにおいて、オブジェクトはあらゆるものの基礎
    * オブジェクトリテラルで作成
        * {}（中カッコ）を書くことで、新しいオブジェクトを作成

##### 配列リテラル

* 配列リテラルは[ ]で値をカンマ区切りで囲み、その値を持つArrayオブジェクトを作成

##### 正規表現リテラル

* 正規表現リテラルは/（スラッシュ）と/（スラッシュ）で正規表現のパターン文字列を囲む
    * 相変らず苦手、、、、

##### プリミティブ型とオブジェクト

* プリミティブ型は基本的にリテラルで表現しますが、真偽値、数値、文字列はそれぞれオブジェクトとして表現する方法もある
    * プリミティブ型の値をラップしたようなオブジェクトであるためラッパーオブジェクトと呼ばれる
         * ただわざわざ使う必要は無い

```
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```

##### まとめ

* 6種類のプリミティブ型とオブジェクトがある
* リテラルはデータ型の値を直接記述できる構文として定義されたもの
* プリミティブ型の真偽値、数値、文字列、nullはリテラル表現がある
* オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
* プリミティブ型のデータでもプロパティアクセスができる