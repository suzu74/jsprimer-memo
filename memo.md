# js-primer memo

### 第一部: 基本文法

#### JavaScriptとは

* JavaScriptは主にウェブブラウザの中で動くプログラミング言語
*  ウェブサイトで操作をしたら表示が書き換わったり、ウェブサイトのサーバーと通信してデータを取得したりと現在のウェブサイトには欠かせないプログラミング言語
     * JavaScriptを活用してアプリケーションのように操作できるウェブサイトをウェブアプリと呼ぶ

* ウェブブラウザだけでなくNode.jsというサーバー側のアプリケーションを作る仕組みでも利用されている。
    * デスクトップアプリやスマートフォンアプリ、IoT（Internet of Things）デバイスでもJavaScriptを使って動かせるものもある
        * つまりかなり広い範囲で使われている

##### JavaScriptとECMAScript

* JavaScriptという言語はECMAScriptという仕様によって動作が決められている
    *  ECMAScriptという仕様では、どの実行環境でも共通な動作のみが定義されている
        * つまり基本的にどの実行環境でも同じ動作をする
            * 一方で、実行環境によって異なる部分もある
                * 実行環境によって必要な機能は異なるため、それらの機能は実行環境ごとに定義（実装）されているため
                    * つまり、、、、ECMAScriptの仕様で定義されている機能を学ぶことで、どの実行環境でも対応できる基本的な部分を学べる

##### JavaScriptってどのような言語？

* 元々Netscape Navigatorというブラウザのために開発されたプログラミング言語
    * 大部分がオブジェクト（値や処理を1つにまとめたもの）で、そのオブジェクト同士のコミュニケーションによって成り立っている 
        * オブジェクトは主に３つ存在する
            * ECMAScriptの仕様として定められたオブジェクト
            * 実行環境が定義したオブジェクト
            * ユーザーの定義したオブジェクト

##### 大文字と小文字を区別する

* JavaScriptは大文字小文字を区別
    * nameという変数を大文字と小文字で書いた場合に、 それぞれは別々のnameとNAMEという名前の変数として認識
    * 大文字で開始しなければならないといった命名規則が意味を持つケースも無い

##### 予約語を持つ

* 特別な意味を持つキーワードがあり、これらは予約語と呼ばれる
     * 変数を宣言するconstも予約語
        * つまりconstという名前の変数名は宣言できない

##### 文はセミコロンで区切られる

* JavaScriptは、文（Statement）ごとに処理していく
    * 文はセミコロン（;）によって区切られる
        *  特殊なルールに基づき、セミコロンがない文も、行末に自動でセミコロンが挿入されるという仕組みも持っている
            * Rubyに慣れているので、セミコロンはつい忘れそう。。。。

#####　strict mode

* 名前のとおり厳格な実行モードで、古く安全でない構文や機能が一部禁止
* `use strict`という文字列をファイルまたは関数の先頭に書くことで、そのスコープにあるコードはstrict modeで実行される
* strict modeでは、evalやwithといったレガシーな機能や構文を禁止
    * さらに明らかな問題を含んだコードに対しては早期的に例外を投げることで、開発者が間違いに気づきやすくしてくれる

* 今まではあまり考えたことなかった、`use strict`だったので意味について再確認できた

#####　実行コンテキスト: ScriptとModule

* 実行コンテキストとして"Script"と"Module"がある
    * 特別意識する必要なし
        *  "Script"の実行コンテキストでは、デフォルトはstrict modeではない
        * "Module"の実行コンテキストでは、デフォルトがstrict modeである

##### JavaScriptの仕様は毎年更新される

* 読了

#### コメント

* コメントに関してはRubyでもあるので書き方は違えどOK
* コメントの書き方には、一行コメントと複数行コメントの2種類

##### 一行コメント

* // 以降から行末までがコメントとして扱われる

##### 複数行コメント

* /* と */で囲まれた範囲がコメントとして扱われる

##### [ES2015] HTML-likeコメント

* HTML-likeコメントは名前のとおり、HTMLのコメントと同じ表記
    * <!-- と -->がコメントとなる

##### まとめ

* コメントの書き方について学んだ
    * 特別難しい内容はなかった。
        * HTML-likeコメンは初耳だった

#### 変数と宣言

* 変数を宣言する方法はconst、let、varの3つ
    * varはもっとも古くからある変数宣言のキーワード(意図しない動作を作りやすい問題があった)
        * ECMAScript 2015で、varの問題を改善するためにconstとletという新しいキーワードが導入

##### [ES2015] const

* constキーワードで、再代入できない変数の宣言とその変数が参照する値（初期値）を定義
    * また、const、let、varどのキーワードも共通の仕組みで、変数同士を,（カンマ）で区切ることにより、同時に複数の変数を定義できる

```
const 変数名 = 初期値;
```

```
const bookTitle = "JavaScript Primer";
const bookCategory = "プログラミング";

上記は以下のように少し簡潔にかける
const bookTitle = "JavaScript Primer",
      bookCategory = "プログラミング";
```

* constは再代入できない変数を宣言するキーワード
    * そのため、constキーワードで宣言した変数に対して、後から値を代入することはできない
        * Rubyは警告はでるが再代入できる、、、。

* 一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られている
    * なので変数に対して値を再代入する必要がない場合は、constキーワードで変数宣言することを推奨
        * 再代入したい場合は次に紹介するletを使う

##### [ES2015] let

* letキーワードでは、値の再代入が可能な変数を宣言できる
    * letはconstとは異なり、初期値を指定しない変数も定義できる
        * 初期値が指定されなかった変数はデフォルト値としてundefinedという値で初期化
            * letで宣言した変数に対しては何度でも値の代入が可能

```
let bookTitle; #まずは初期化
bookTitle = "JavaScript Primer";
```

```
let count = 0;
count = 1; # 一度letで宣言しているのであとは宣言しないで大丈夫、、、、
count = 2;
count = 3;
```

#####　varの問題

* varはletとよく似ていますが、varキーワードには同じ名前の変数を再定義できてしまう問題がある
    * letやconstでは、同じ名前の変数を再定義すると構文エラーになる
    * 一方、varは同じ名前の変数を再定義できる
        * letはvarを改善したバージョン」
            * varの問題についてあまり意識したことがなかった、、、、。

```
// "x"という変数名で変数を定義する
let x;
// 同じ変数名の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x

// "x"という変数を定義する
var x = 1;
// 同じ変数名の変数"x"を定義できる
var x = 2;
// 変数xは2となる
```

##### [コラム] なぜletやconstは追加されたのか？

* 読了

##### 変数名に使える名前のルール

* 変数名の名前（識別子）のルール
    * 半角のアルファベット、_（アンダースコア）、$（ダラー）、数字を組み合わせた名前にする
    * 変数名は数字から開始できない
    * 予約語と被る名前は利用できない
        * 予約語とは、varのとかifように構文として意味を持つキーワード

##### [コラム] constは定数ではない

* constは「再代入できない変数」を定義する変数宣言
    * 必ずしも定数を定義するわけではない

* では定数とは？？
    * 定数とは、一度定義した名前（変数名）が常に同じ値を示すもの
         * const宣言によって定数に近い変数を定義できる
            * const宣言によって定義した変数を、変更できないプリミティブな値で初期化すれば、それは実質的に定数となる
                * プリミティブな値とは、数値や文字列などオブジェクト以外のデータ（他のパートで詳しく学ぶ）
            * しかしオブジェクトなどもconst宣言できる
                * オブジェクトという値そのものは、初期化したあとでも変更可
                    * てっきりconstは定数宣言だと思っていた、、、、。
            * const宣言の特性として「再代入できない変数」を定義すると覚えておく

```
// `const`でオブジェクトを定義している
const object = {
    key: "値"
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値";
```

#####　まとめ

* constは、再代入できない変数を宣言できる
* letは、再代入ができる変数を宣言できる
* varは、再代入ができる変数を宣言できる
    * しかし、varにはいくつかの問題が知られている

* constは再代入を禁止することで、ミスから発生するバグを減らすことが期待できる
    * 変数を宣言する場合には、まずconstで定義できないかを検討し、できない場合はletを使うことを推奨されている

#### 値の評価と表示

* 値の評価方法について学ぶ
    * 値の評価とは、入力した値を評価してその結果を返すこと

##### ブラウザでJavaScriptを実行する

* 読了

##### Console API

* デバッグとして便利

##### コードの評価とエラー

* エラーには多く分けて構文エラーと実行時エラーの2種類

##### 構文エラー

* JavaScriptエンジンは、コードをパース（解釈）してから、プログラムとして実行できる形に変換して実行
    * コードをパースする際に文法の問題が見つかると、その時点で構文エラーが発生する

##### 実行時エラー

* プログラムを実行している最中に発生するエラー
    * APIに渡す値の問題から起きるTypeErrorや存在しない変数を参照しようとして起きるReferenceErrorなどさまざまな種類がある
        * 構文は正しいが、別でエラーが起きている

* どこまではちゃんと実行できたか順番に追っていくような、エラーの原因を特定する作業が必要になる場合がある

#####　まとめ

* 読了

#### データ型とリテラル

##### データ型

* JavaScriptは動的型付け言語
    * 静的型付け言語のような変数の型はない
        * しかし、文字列、数値、真偽値といった値の型は存在 ⇨　値の型のことをデータ型
            * 今まで静的型付け言語を学んだことが無いから、ここら辺の違いの理解が曖昧

* データ型は大きく分けて２つ(プリミティブ型とオブジェクト)
    * プリミティブ型
        * 真偽値や数値などの基本的な値の型
            * 一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性をもつ
            * 文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種
    * オブジェクト（複合型）
        * オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合
            * 一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性
                * 値そのものではなく値への参照を経由して操作されるため、参照型のデータとも呼ばれる

* データ型を細かく見ていくと、6つのプリミティブ型とオブジェクト
    * 真偽値（Boolean）、数値（Number）、文字列（String）、undefined、 null、 シンボル（Symbol）
    * 上記以外がオブジェクト(オブジェクト、配列、関数、正規表現、Dateなど)
    * typeof演算子を使うことで調べることが可能
        * ただし、typeof nullが"object"となるのは、仕様のバグ
        * 配列とオブジェクトがどちらも"object"という判定結果
            * 基本的にtypeof演算子は、プリミティブ型またはオブジェクトかを判別するものです。 オブジェクトの詳細な種類を判定できない

##### リテラル

* リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの
    * 例）　"と"で囲んだ範囲が文字列リテラル

#####　真偽値（Boolean）

* 真偽値にはtrueとfalseのリテラルがある

#####　数値（Number）

* 数値は大きく分けて42のような整数リテラルと3.14159のような浮動小数点数リテラルの２種類
    * さらに整数リテラルには4種類
        * 10進数 2進数 8進数 16進数
            * 上記の理解が曖昧。再度復習の余地あり
    *  浮動小数点数は2種類の表記
        * 3.14159 のような .（ドット）を含んだ数値
            * 0からはじまる浮動小数点数は、0を省略可
                * .をオブジェクトにおいて利用する機会が多いため、 0からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせる
        * 2e8 のような e または E を含んだ数値

##### 文字列（String）

* ダブルクォートとシングルクォートで囲った場合は全く同じ
    * Rubyとは違う、、、、。
* ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できないので、\nを使う
    * テンプレートリテラルは違って、直感的にかける！
        * ただし、他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、\を使ってエスケープする必要あり

##### nullリテラル

* nullは「値がない」ということを表現する値

##### [コラム] undefinedはリテラルではない

* undefinedはただのグローバル変数で、undefinedという値を持っているだけ
    * つまり、undefinedには値を代入できる（非推奨）
    * あまり、nullとかundefinedを意識したことがなかった

##### オブジェクトリテラル

* JavaScriptにおいて、オブジェクトはあらゆるものの基礎
    * オブジェクトリテラルで作成
        * {}（中カッコ）を書くことで、新しいオブジェクトを作成

##### 配列リテラル

* 配列リテラルは[ ]で値をカンマ区切りで囲み、その値を持つArrayオブジェクトを作成

##### 正規表現リテラル

* 正規表現リテラルは/（スラッシュ）と/（スラッシュ）で正規表現のパターン文字列を囲む
    * 相変らず苦手、、、、

##### プリミティブ型とオブジェクト

* プリミティブ型は基本的にリテラルで表現しますが、真偽値、数値、文字列はそれぞれオブジェクトとして表現する方法もある
    * プリミティブ型の値をラップしたようなオブジェクトであるためラッパーオブジェクトと呼ばれる
         * ただわざわざ使う必要は無い

```
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```

##### まとめ

* 6種類のプリミティブ型とオブジェクトがある
* リテラルはデータ型の値を直接記述できる構文として定義されたもの
* プリミティブ型の真偽値、数値、文字列、nullはリテラル表現がある
* オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
* プリミティブ型のデータでもプロパティアクセスができる

#### 演算子

* 演算子は演算する対象を持ちます。この演算子の対象のことを被演算子（オペランド）と呼ぶ
    * 例）　`1 + 3`　の場合、1と3という2つの値がオペランド
        * 上記のように2つのオペランドを取る演算子を二項演算子と呼ぶ
        * また、`++`のように1つのオペランドを取る演算子を単項演算子と呼ぶ

##### 二項演算子

 * 読了

##### 単項演算子（算術）

* NaNは"Not-a-Number"の略称で、数値ではないがNumber型の値を表現している
    * NaNはどの値とも（NaN自身に対しても）一致しない特性がある

* インクリメント演算子（++）は、オペランドの後ろに置くか前に置くかで、それぞれで評価の順番が異なる
    * 同じようでも微妙に異なるので注意が必要

* 等価演算子について
    * `===`を使うべき
        * `==`は暗黙的な型変換をするため
        * 原則は厳密等価演算子（===）を使い、異なる型を比較したい場合は明示的に型を合わせるべき
    * 同じように、`!==`を使うべき

##### ビット演算子

* ここら辺は知識不足のせいかイマイチつかめず、、、、汗
    * 細かいことは今回は割愛する

* ビット否定（~）
    * 否定演算子（~）はビット演算以外でも使われていることがある
        * 文字列（Stringオブジェクト）が持つindexOfメソッドは、マッチする文字列を見つけて、そのインデックス（位置）を返すメソッド

```
const str = "森森本森森";
// 見つかった場合はインデックスを返す
// JavaScriptのインデックスは0から開始するので2を返す
console.log(str.indexOf("本")); // => 2
// 見つからない場合は-1を返す
console.log(str.indexOf("火")); // => -1
```

* JavaScriptでは0も、if文ではfalse
    * Rubyとは違う、、、！

* ES2015では、文字列にincludesメソッドが実装された
    * includesメソッドは指定した文字列が含まれているかを真偽値で返す

##### [ES2015] 分割代入（Destructuring assignment）

* 今まで見てきた代入演算子は1つの変数に値を代入するもの
    * 分割代入を使うことで、配列やオブジェクトの値を複数の変数へ同時に代入できる
        * オブジェクトの分割代入の方が少しわかりにくい、、、見慣れないせいかも！

```
const array = [1, 2];
const a = array[0];
const b = array[1];

# 上記を簡単に書くと、、、

const array = [1, 2];
// aには`array`の0番目の値、bには1番目の値が代入される
const [a, b] = array;
console.log(a); // => 1
console.log(b); // => 2
```

##### 条件（三項）演算子（?と:）

* 基本的な使いかたは大丈夫そう

##### NOT演算子（!）

* オペランドの評価結果がtrueであるならば、falseを返す
    * !!みたいな使い方がよくわからない、、、、。
        * ただし、このようなケースの多くは、比較演算子を使うなどより明示的な方法で、真偽値を得ることができる
            * 安易に!!による変換に頼るよりは別の方法を探してみるのもあり

#####　カンマ演算子（,）

* カンマで区切った式は左から順に評価される

##### まとめ

* 様々な演算子について学んだ
    * 一度に全ては無理そうなので、適宜見返すで良さそう

#### 暗黙的な型変換

* 等価演算子（==）ではなく厳密等価演算子（===）の利用を推奨されている
    * それは厳密等価演算子が暗黙的な型変換をせずに、値同士を比較できるため
        * 例えば厳密等価演算子（===）では異なるデータ型を比較した場合に、その比較結果は必ずfalseになる
        * しかし、等価演算子（==）では異なるデータ型を比較した場合に、同じ型となるように暗黙的な型変換をしてから比較

* 別の暗黙的な型変換の例
    * 数値と真偽値の加算
        * 多くの言語では、数値と真偽値の加算のような異なるデータ型同士の加算はエラーとなる
            * しかし、JSではは暗黙的な型変換が行われてから加算されるため、エラーなく処理されてしまう

* エラーが発生するのではなく、暗黙的な型変換が行われてしまうケースが多くある
    * そうするとバグの発見などが難しくなるケースがある

* よって、、、、暗黙的な型変換はできる限り避けるべき挙動

##### 暗黙的な型変換とは

* ある処理において、その処理過程で行われる明示的ではない型変換のこと
    * 暗黙的な型変換は、演算子による演算や関数の処理過程で行われる
        * もっとも有名な暗黙的な型変換は、等価演算子(==)
            * 多くの数があるから覚える必要は無い
                * よって`===`を使うことで避けることで対応する

* 他の暗黙的な型変換について
    * `1 + "2"; // => "12"` となる
        * プラス演算子（+）は、数値の加算と文字列の結合を両方実行できるように多重定義されていて、文字列の結合を優先する仕様となっているため
    * `1 - "2"; // => -1`になる
        * これは`-`が文字列に対して定義されていないため、数値への暗黙的な型変換が行われる
    * 3つ以上の値を+演算子で演算する場合に、値の型が混ざっていると、 演算する順番によっても結果が異なってしまう
    * 以上のように、処理の過程でオペランドの型によって、 自動的に変換されることを暗黙的な型変換と呼ぶ
        * 暗黙的な型変換では、結果の値の型はオペランドの型に依存
            * それを避けるために明示的な型変換をする
    
##### 明示的な型変換をする

* 任意の値 → 真偽値
    * Booleanコンストラクタ関数を使うことで、任意の値をtrueまたはfalseの真偽値に変換可
        * falsyな値はfalse　そうではない値はtrue
            * falsyな値とは次の6種類の値のことを言います
                * false undefined null 0 NaN ""（空文字列）
                    * この変換ルールはif文の条件式の評価と同様

* 数値 → 文字列
    * 数値から文字列へ明示的に変換する場合は、Stringコンストラクタ関数を使う
        * `String(1); // => "1"`
            * Stringコンストラクタ関数での変換は、あくまでプリミティブ型に対してのみに留めるべき

* シンボル → 文字列
    * ES2015で追加されたプリミティブ型であるシンボルは暗黙的に型変換できない
        * 文字列結合演算子をシンボルに対して利用すると例外を投げる
            * そのため、片方が文字列であるからといってプラス演算子の結果は必ず文字列になるとは限らない
                * `"文字列と" + String(Symbol("シンボルの説明")); // => "文字列とSymbol(シンボルの説明)"`

* 文字列 → 数値
    * 文字列から数値に変換する典型的なケースとしては、ユーザー入力として数字を受け取る場合
        * ユーザー入力は文字列でしか受け取ることができないため、それを数値に変換してから利用する必要あり(formとかも文字列だけ、、、？)
            * 文字列から数値へ明示的に変換するにはNumberコンストラクタ関数が利用
            * また、文字列から数字を取り出して変換する関数としてNumber.parseInt、Number.parseFloatも利用可
                * parseIntとかparseFloatは以前に見たことはあった

* NaNはNot a NumberだけどNumber型
    * 特殊な性質を持つNumber型のデータ
        * NaNという値を作る方法は簡単で、Number型と互換性のない性質のデータをNumber型へ変換した結果はNaNとなる

```
// NaNはnumber型
console.log(typeof NaN); // => "number"
```

* NaNは何と演算しても結果はNaNになる特殊な値
    * 従って、NaNは暗黙的な型変換の中でももっとも避けたい値
        * 計算していた値がどこでNaNとなったのかがわかりにくく、デバッグが難しいため

* この意図しないNaNへの変換を避ける方法として、大きく分けて２つの方法があります。
    * sum関数側（呼ばれる側）で、Number型の値以外を受けつけなくする
    * sum関数を呼び出す側で、Number型の値のみを渡すようにする

* JavaScriptは、型エラーに対して暗黙的な型変換をしてしまうなど、驚くほど曖昧さを許容している
    * よって検出しにくいバグを見つけられるように書くことが重要

##### 明示的な変換でも解決しないこと

* 明示的な変換をする前に、まず変換がそもそも必要なのかを考える必要がある

##### まとめ

* 厳密等価演算子（===）を利用する
* 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
* 真偽値を得るには、明示的な型変換以外の方法もある
* ここまででデータ型に対して考えたことがなかったので、シンプルな内容だったとはいえ、しっかり理解しておきたい
* 暗黙の型変換ということが起こらないような実装を心がける

#### 関数と宣言

* 関数とは、ある一連の手続き（文の集まり）を1つの処理としてまとめる機能

##### 関数宣言

* 関数を定義するためにfunctionキーワードを使用
    * functionからはじまる文は関数宣言と呼ぶ

* 関数は次の4つの要素で構成
    * 関数名 - 利用できる名前は変数名と同じ
    * 仮引数 - 関数の呼び出し時に渡された値が入る変数。複数ある場合は,（カンマ）で区切る
    * 関数の中身 - {と}で囲んだ関数の処理を書く場所
    * 関数の返り値 - 関数を呼び出したときに、呼び出し元へ返される値
        * returnを書くことを忘れずに、、、！

##### 関数の引数

* JavaScriptでは、関数に定義した仮引数の個数と実際に呼び出したときの引数の個数が違っても、関数を呼び出せる
    * そのため、引数の個数が合っていないときの挙動を知る必要がある

* 呼び出し時の引数が少ないとき
    * 定義した関数の仮引数よりも呼び出し時の引数が少ない場合、余った仮引数にはundefinedという値が代入される

* [ES2015] デフォルト引数
    * デフォルト引数（デフォルトパラメータ）は、仮引数に対応する引数が渡されていない場合に、デフォルトで代入される値を指定できる

* 呼び出し時の引数が多いとき
    * 関数の仮引数に対して引数の個数が多い場合、あふれた引数は単純に無視

* 可変長引数
    * 任意の個数の引数を受け取りたい場合に使える

* [ES2015] Rest parameters
    * 仮引数名の前に...をつけた仮引数のこと
        * 関数に渡された値が配列として代入

* Spread構文
    * Spread構文は、配列の前に...をつけた構文のことで、関数には配列の値を展開したものが引数として渡される

* arguments
    * 可変長引数を扱う方法として、argumentsという関数の中でのみ参照できる特殊な変数がある
        * argumentsは関数に渡された引数の値がすべて入ったArray-likeなオブジェクト
            * あまり推奨されていないので割愛

##### [ES2015] 関数の引数と分割代入

* 関数の引数においても分割代入（Destructuring assignment）が利用できる
    * 分割代入はオブジェクトや配列からプロパティを取り出し、変数として定義し直す構文

```
function printUserId(user) {
    console.log(user.id); // => 42
}
const user = {
    id: 42
};
printUserId(user);

上記のコードは、、、
function printUserId({ id }) {
    console.log(id); // => 42
}
const user = {
    id: 42
};
printUserId(user);
とも書ける
```

* 関数の引数における分割代入は、オブジェクトだけではなく配列についても利用可

```
function print([first, second, third]) {
    console.log(first); // => 1
    console.log(second); // => 2
    console.log(third); // => 3
}
const array = [1, 2, 3];
print(array);
```

##### 関数はオブジェクト

* 関数は関数オブジェクトとも呼ばれ、オブジェクトの一種
    * 関数名に()をつけることでまとめた処理を呼び出すことができる

* 一方で、()をつけて呼び出されなければ、関数をオブジェクトとして参照できる
    * つまり、ほかの値と同じように変数へ代入したり、関数の引数として渡すことが可能
        * 関数が値として扱えることを、ファーストクラスファンクション（第一級関数）と呼ぶ

* 関数式
    * 関数式とは、関数を値として変数へ代入している式のこと
        * 関数宣言は文でしたが、関数式では関数を値として扱っています。 これは、文字列や数値などの変数宣言と同じ定義方法
            * 関数式ではfunctionキーワードの右辺に書く関数名は省略
            *  一方、関数宣言ではfunctionキーワードの右辺の関数名は省略
                * 名前を持たない関数を匿名関数（または無名関数）と呼ぶ

```
// 関数式
// functionの後に関数名は省略する
const 関数名 = function() {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返り値;
};
```

* [ES2015] Arrow Function
    * もう一つの匿名関数を定義する構文
        * functionキーワードに比べて短く書けるようになっている

```
// Arrow Functionを使った関数定義
const 関数名 = () => {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返す値;
};
```

* Arrow Functionには省略記法
    * 関数の仮引数が1つのときは()を省略できる
    * 関数の処理が1つの式である場合に、ブロックとreturn文を省略できる
        * その式の評価結果をreturnの返り値とする

```
// 仮引数の数と定義
const fnA = () => { /* 仮引数がないとき */ };
const fnB = (x) => { /* 仮引数が1つのみのとき */ };
const fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };
const fnD = (x, y) => { /* 仮引数が複数のとき */ };
// 値の返し方
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```

* 上記は１度に覚えるのは難しいので、軽く頭に入れる程度に留める

* Arrow Functionの特徴
    * 名前をつけることができない（常に匿名関数）
    * thisが静的に決定できる
    * functionキーワードに比べて短く書くことができる
    * newできない（コンストラクタ関数ではない）
    * arguments変数を参照できない

* Arrow Functionでは処理が1つの式だけである場合に、return文を省略し暗黙的にその式の評価結果をreturnの返り値
* Arrow Functionは仮引数が1つである場合は()を省略
    * ここら辺のルール的なのが曖昧、しかし、実際に書いて行くことで覚えていくしかない

##### [コラム] 同じ名前の関数宣言は上書きされる

* 同じ関数名で複数の関数を定義することは無意味のため避けるべき

* 引数として渡される関数のことをコールバック関数と呼ぶ
    * 一方、コールバック関数を引数として使う関数やメソッドのことを高階関数と呼ぶ

```
const array = [1, 2, 3];
const output = (value) => {
    console.log(value);
};
array.forEach(output);
```

* オブジェクトのプロパティである関数をメソッドと呼ぶ
    * JavaScriptにおいて、関数とメソッドの機能的な違いはない

* [ES2015] メソッドの短縮記法

```
const obj = {
    method() {
        return "this is method";
    }
};
console.log(obj.method()); // => "this is method"
```

##### まとめ

* 基本的な宣言の仕方などはわかってはいたが、細かいルール的を意識したことがなかった
    * 全て一度に覚えるのは難しいので、必要になった際に都度調べて復習していくことにすると良さそう

#### 文と式

* JavaScriptは、文（Statement）と式（Expression）から構成されている

##### 式

* 式とは、、、
    * 値を生成し、変数に代入できるもの
        * 42のようなリテラルやfooといった変数、関数呼び出しや1+1も式
            * 要は評価した結果を変数に代入できるものは式

##### 文

* 文とは、、、
    * 処理する1ステップが1つの文
        * 文の末尾にセミコロン(;)を置くことで文と文に区切りをつける
        * たとえば、if文やfor文などが文と呼ばれる

* if文などは文であり式にはなれない
    * つまり、、、if文を変数へ代入することはできない

##### 式文

* 式（Expression）は文（Statement）になることができ、文となった式のことを式文と呼ぶ
    * 文の一種であるため、セミコロンで文を区切る

* ブロック文
    * 文を{と}で囲んだ部分をブロックと呼ぶ

* 文の末尾にはセミコロンをつけるとしていたが、 例外としてブロックで終わる文の末尾には、セミコロンが不要

```
// ブロックで終わらない文なので、セミコロンが必要
if (true) console.log(true);
// ブロックで終わる文なので、セミコロンが不要
if (true) {
    console.log(true);
}
```

##### [コラム] 単独のブロック文の活用

* 読了

##### function宣言（文）とfunction式

* 関数を定義する方法は2つ
    * functionキーワードから文を開始する関数宣言と、変数へ関数式を代入する方法

```
// learn関数を宣言する関数宣言文
function learn() {
}
// 関数式をread変数へ代入
const read = function() {
};
```

* 上記において
    * 関数宣言（文）で定義したlearn関数には、セミコロンがない。 
        * これは、ブロックで終わる文にはセミコロンが不要なため
    * 一方、関数式をread変数へ代入したものには、セミコロンがある
        * この匿名関数は式であり、この処理は変数を宣言する文の一部なので末尾にセミコロンが必要

##### まとめ

* JavaScriptは文（Statement）と式（Expression）から構成される* 
* 文は式になれない
* 式は文になれる（式文）
* 文の末尾にはセミコロンをつける
* ブロックで終わる文は例外的にセミコロンをつけなくてよい

* 文と式の違いなどを意識したことなかったので多少は頭に入れておきたい
* Rubyに慣れているためセミコロンの意識が薄い
* 今まで「なぜセミコロンを入れない場合がある」のか少し疑問に思っていたが、今回ので少し理解できた
